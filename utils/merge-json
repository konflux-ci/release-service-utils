#!/usr/bin/env sh
#
# Script: merge_json.sh
#
# Description: This script merges two JSON strings into a new JSON object,
#              overriding keys from the first JSON with keys from the second
#              JSON if there's a collision.
#
# Usage: merge_json.sh <json1> <json2>
#
# Parameters:
#   <json1> - First JSON string
#   <json2> - Second JSON string
#
# Requirements:
#   - This script requires the 'jq' command-line JSON processor.
#     Ensure that 'jq' is installed on your system.
#
# Notes:
#   - Both JSON strings must be valid JSON.
#   - If either JSON string is not valid, the script will exit with an error.


# Check if both JSON strings are provided as arguments
if [ $# -ne 2 ]; then
  echo "Usage: $0 <json1> <json2>"
  exit 1
fi

# Store the JSON strings in variables
json1="$1"
json2="$2"

# Validate JSON input
if ! echo "$json1" | jq -e . >/dev/null 2>&1; then
  echo "Error: Invalid JSON in parameter 1"
  exit 1
fi

if ! echo "$json2" | jq -e . >/dev/null 2>&1; then
  echo "Error: Invalid JSON in parameter 2"
  exit 1
fi

# Merge the JSON objects recursively, combining arrays and replacing other values
merged_json=$(printf '%s\n%s' "$json1" "$json2" | jq -cs '
def merge_objects(a; b):
  a as $a | b as $b |
  ($a | keys) + ($b | keys) | unique | map({
    key: .,
    value: (
      if ($a[.] | type) == "object" and ($b[.] | type) == "object" then
        merge_objects($a[.]; $b[.])
      elif ($a[.] | type) == "array" and ($b[.] | type) == "array" then
        ($a[.] + $b[.]) | unique
      else
        $b[.] // $a[.]
      end
    )
  }) | from_entries;

.[0] as $first | .[1] as $second | merge_objects($first; $second)
')
# Print the merged JSON
echo "$merged_json"
